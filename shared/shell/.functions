#!/usr/bin/env bash

# -d for recursive removing untracked files -f force, delete directories
red() {
	git reset --hard HEAD
	git clean -df
}

# "check out a given PR for review"
revpr() {
  gh co $1
  git reset --mixed master
}

search() {
	if [[ "$#" -ne 1 ]]; then
        echo "Error: Please provide exactly one argument enclosed in quotes."
        return 1
    fi

	local pattern="$1"
    grep -Rnw . -e "$pattern"
}

ups() {
	git remote add upstream $@
	git fetch upstream
	git pull upstream/main
	git push
}

pk() {
	lsof -i :"$1" -s TCP:LISTEN -t | xargs kill
}

# Create a new directory and enter it
mkd() {
	mkdir -p "$@" && cd "$_";
}

# Extract most know archives with one command
extract () {
    if [[ -f $1 ]] ; then
      case $1 in
        *.tar.bz2)   tar xjf $1     ;;
        *.tar.gz)    tar xzf $1     ;;
        *.bz2)       bunzip2 $1     ;;
        *.rar)       unrar e $1     ;;
        *.gz)        gunzip $1      ;;
        *.tar)       tar xf $1      ;;
        *.tbz2)      tar xjf $1     ;;
        *.tgz)       tar xzf $1     ;;
        *.zip)       unzip $1       ;;
        *.Z)         uncompress $1  ;;
        *.7z)        7z x $1        ;;
        *)     echo "'$1' cannot be extracted via extract()" ;;
         esac
     else
         echo "'$1' is not a valid file"
     fi
}

# Determine size of a file or total size of a directory
fs() {
	if du -b /dev/null > /dev/null 2>&1; then
		local arg=-sbh;
	else
		local arg=-sh;
	fi
	if [[ -n "$@" ]]; then
		du $arg -- "$@";
	else
		du $arg .[^.]* ./*;
	fi;
}

# Use Git's colored diff when available
if hash git &>/dev/null; then
	diff() {
		git diff --no-index --color-words "$@";
	}
fi;

# Compare original and gzipped file size
gz() {
	local origsize=$(wc -c < "$1");
	local gzipsize=$(gzip -c "$1" | wc -c);
	local ratio=$(echo "$gzipsize * 100 / $origsize" | bc -l);
	printf "orig: %d bytes\n" "$origsize";
	printf "gzip: %d bytes (%2.2f%%)\n" "$gzipsize" "$ratio";
}

# UTF-8-encode a string of Unicode symbols
escape() {
	printf "\\\x%s" $(printf "$@" | xxd -p -c1 -u);
	# print a newline unless we're piping the output to another program
	if [[ -t 1 ]]; then
		echo ""; # newline
	fi;
}

# Show all the names (CNs and SANs) listed in the SSL certificate
# for a given domain
getcertnames() {
	if [[ -z "${1}" ]]; then
		echo "ERROR: No domain specified.";
		return 1;
	fi;

	local domain="${1}";
	echo "Testing ${domain}â€¦";
	echo ""; # newline

	local tmp=$(echo -e "GET / HTTP/1.0\nEOT" \
		| openssl s_client -connect "${domain}:443" -servername "${domain}" 2>&1);

	if [[ "${tmp}" = *"-----BEGIN CERTIFICATE-----"* ]]; then
		local certText=$(echo "${tmp}" \
			| openssl x509 -text -certopt "no_aux, no_header, no_issuer, no_pubkey, \
			no_serial, no_sigdump, no_signame, no_validity, no_version");
		echo "Common Name:";
		echo ""; # newline
		echo "${certText}" | grep "Subject:" | sed -e "s/^.*CN=//" | sed -e "s/\/emailAddress=.*//";
		echo ""; # newline
		echo "Subject Alternative Name(s):";
		echo ""; # newline
		echo "${certText}" | grep -A 1 "Subject Alternative Name:" \
			| sed -e "2s/DNS://g" -e "s/ //g" | tr "," "\n" | tail -n +2;
		return 0;
	else
		echo "ERROR: Certificate not found.";
		return 1;
	fi;
}

# `v` with no arguments opens the current directory in Vim, otherwise opens the
# given location
v() {
	if [[ $# -eq 0 ]]; then
		vim .;
	else
		vim "$@";
	fi;
}

# docker functions
dcleanup(){
	local containers
	containers=($(docker ps -aq 2>/dev/null))
	[[ ${#containers[@]} -gt 0 ]] && docker rm "${containers[@]}" 2>/dev/null
	local volumes
	volumes=($(docker ps --filter status=exited -q 2>/dev/null))
	[[ ${#volumes[@]} -gt 0 ]] && docker rm -v "${volumes[@]}" 2>/dev/null
	local images
	images=($(docker images --filter dangling=true -q 2>/dev/null))
	[[ ${#images[@]} -gt 0 ]] && docker rmi "${images[@]}" 2>/dev/null
}

rename_last_commit(){
	git commit --amend -m "$1"
}

# https://sqlformat.org/api/
sqlformat(){
	curl -s --location --request POST 'https://sqlformat.org/api/v1/format' \
	--header 'Content-Type: application/x-www-form-urlencoded' \
	--data-urlencode 'reindent=1' \
	--data-urlencode 'indent_width=3' \
	--data-urlencode 'keyword_case=upper' \
	--data-urlencode 'strip_comments=1' \
	--data-urlencode "sql=$1" | jq -r '.result'
}